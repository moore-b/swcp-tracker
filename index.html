<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SW Coast Path Tracker</title>
   
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gpx-parse/0.10.3/gpx-parse.min.js" defer></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js' defer></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { height: 500px; width: 100%; border-radius: 0.5rem; }
        .btn-strava { background-color: #FC5200; }
        .btn-strava:hover { background-color: #e04a00; }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 24px; height: 24px; animation: spin 1s linear infinite;
            display: inline-block; margin-right: 10px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">South West Coast Path Tracker</h1>
            <p class="mt-2 text-lg text-gray-600">Log your progress on the 630-mile journey.</p>
        </header>

        <main id="main-content">
            <div id="config-section" class="bg-white p-6 rounded-lg shadow-md mb-8">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-3">1. Connect to Strava</h2>
                <div class="space-y-4">
                    <div>
                        <label for="clientId" class="block text-sm font-medium text-gray-700">Client ID</label>
                        <input type="text" id="clientId" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                    <div>
                        <label for="clientSecret" class="block text-sm font-medium text-gray-700">Client Secret</label>
                        <input type="password" id="clientSecret" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                <button id="connect-button" class="mt-6 w-full btn-strava text-white font-bold py-3 px-4 rounded-lg transition" disabled>
                    Connect with Strava
                </button>
            </div>

            <div id="progress-section" class="hidden bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4 border-b pb-3">
                     <h2 class="text-2xl font-semibold">2. Your Progress</h2>
                     <div id="strava-user-info" class="text-right"></div>
                </div>
                <div class="mb-6">
                    <p class="text-lg">Overall Completion: <span id="progress-percentage" class="font-bold text-blue-600">0.00%</span></p>
                    <p class="text-sm text-gray-500">Completed Distance: <span id="completed-distance">0.00</span> km / <span id="total-distance">0.00</span> km</p>
                    <div class="w-full bg-gray-200 rounded-full h-4 mt-2">
                        <div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                </div>
                <h3 class="text-xl font-semibold mb-3">Map of the Path</h3>
                <div id="map"></div>
                <div class="flex space-x-4 mt-6">
                    <button id="analyze-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center" disabled>
                        <span id="analyze-button-text">Analyze New Activities</span>
                    </button>
                    <button id="reset-button" class="w-1/3 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg">
                        Reset Progress
                    </button>
                </div>
                 <div class="mt-4">
                    <button id="update-strava-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center" disabled>
                        <span id="update-strava-text">Update Strava Activity Titles</span>
                    </button>
                </div>
            </div>

            <div id="status-log-section" class="mt-8">
                <h3 class="text-xl font-semibold mb-2">Status Log</h3>
                <div id="status-log" class="bg-gray-900 text-white font-mono text-sm rounded-lg p-4 h-48 overflow-y-auto"></div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const OFFICIAL_GPX_URL = 'https://api.allorigins.win/raw?url=https://www.nationaltrail.co.uk/fs/i/gpx/south-west-coast-path.gpx';
            const DISTANCE_THRESHOLD_METERS = 100;
            const PROCESSED_ACTIVITIES_KEY = 'swcp_processed_activities';
            const COMPLETED_POINTS_KEY = 'swcp_completed_points';
            const SWCP_DATA_KEY = 'swcp_geojson_data';
           
            // DOM Elements
            const clientIdInput = document.getElementById('clientId');
            const clientSecretInput = document.getElementById('clientSecret');
            const connectButton = document.getElementById('connect-button');
            const configSection = document.getElementById('config-section');
            const progressSection = document.getElementById('progress-section');
            const analyzeButton = document.getElementById('analyze-button');
            const analyzeButtonText = document.getElementById('analyze-button-text');
            const resetButton = document.getElementById('reset-button');
            const updateStravaButton = document.getElementById('update-strava-button');
            const updateStravaText = document.getElementById('update-strava-text');
            const statusLog = document.getElementById('status-log');
            const stravaUserInfo = document.getElementById('strava-user-info');
            const progressBar = document.getElementById('progress-bar');
            const progressPercentageEl = document.getElementById('progress-percentage');
            const completedDistanceEl = document.getElementById('completed-distance');
            const totalDistanceEl = document.getElementById('total-distance');

            // Global State
            let map;
            let swcpGeoJSON;
            let swcpTotalDistance = 0;
            let completedSegmentsLayer;
            let currentPercentage = 0;

            const log = (message, type = 'info') => {
                const now = new Date().toLocaleTimeString();
                const color = type === 'error' ? 'text-red-400' : (type === 'success' ? 'text-green-400' : 'text-gray-300');
                statusLog.innerHTML += `<p><span class="text-gray-500">${now}:</span> <span class="${color}">${message}</span></p>`;
                statusLog.scrollTop = statusLog.scrollHeight;
                if (type === 'error') console.error(message);
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
           
            const init = async () => {
                log('App initialized. Waiting for user input.');
               
                clientIdInput.addEventListener('input', checkInputs);
                clientSecretInput.addEventListener('input', checkInputs);
                connectButton.addEventListener('click', connectToStrava);
                resetButton.addEventListener('click', resetProgress);
                analyzeButton.addEventListener('click', analyzeAllActivities);
                updateStravaButton.addEventListener('click', updateStravaTitles);
               
                clientIdInput.value = sessionStorage.getItem('stravaClientId') || '';
                clientSecretInput.value = sessionStorage.getItem('stravaClientSecret') || '';
                checkInputs();

                const urlParams = new URLSearchParams(window.location.search);
                const authCode = urlParams.get('code');

                if (authCode) await getAccessToken(authCode);
                else if (sessionStorage.getItem('stravaAccessToken')) await showProgressSection();
                else log('Please connect to Strava.');
            };
           
            function checkInputs() {
                if (connectButton) connectButton.disabled = !(clientIdInput.value.trim() && clientSecretInput.value.trim());
            }
       
            function connectToStrava() {
                sessionStorage.setItem('stravaClientId', clientIdInput.value.trim());
                sessionStorage.setItem('stravaClientSecret', clientSecretInput.value.trim());
                const redirectUri = window.location.origin + window.location.pathname;
                const scope = 'read,activity:read_all,activity:write';
                const authUrl = `https://www.strava.com/oauth/authorize?client_id=${clientIdInput.value.trim()}&redirect_uri=${redirectUri}&response_type=code&scope=${scope}`;
                window.location.href = authUrl;
            }

            async function getAccessToken(code) {
                log('Exchanging authorization code for access token...');
                try {
                    const response = await fetch('https://www.strava.com/oauth/token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            client_id: sessionStorage.getItem('stravaClientId'),
                            client_secret: sessionStorage.getItem('stravaClientSecret'),
                            code: code, grant_type: 'authorization_code'
                        }),
                    });
                    const data = await response.json();
                    if (data.access_token) {
                        log('Success! Access Token received.', 'success');
                        sessionStorage.setItem('stravaAccessToken', data.access_token);
                        sessionStorage.setItem('stravaAthlete', JSON.stringify(data.athlete));
                        window.location.href = window.location.pathname;
                    } else { log(`Error getting access token: ${data.message}`, 'error'); }
                } catch (error) { log(`Network error: ${error.message}`, 'error'); }
            }
           
            async function showProgressSection() {
                configSection.style.display = 'none';
                progressSection.style.display = 'block';

                const athlete = JSON.parse(sessionStorage.getItem('stravaAthlete') || '{}');
                if(athlete.firstname) stravaUserInfo.innerHTML = `<p class="font-semibold">${athlete.firstname} ${athlete.lastname}</p>`;
               
                await initializeMap();
                loadProgressFromStorage();
            }

            async function initializeMap() {
                log('Initializing map...');
                map = L.map('map').setView([50.5, -4.0], 8);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);
                completedSegmentsLayer = L.layerGroup().addTo(map);

                const storedData = localStorage.getItem(SWCP_DATA_KEY);
                if (storedData) {
                    log('Loading map data from browser storage.', 'success');
                    processSwcpData(storedData, false);
                    return;
                }
               
                log('Fetching official SWCP route data... (this may take a moment on first load)');
                try {
                    const response = await fetch(OFFICIAL_GPX_URL);
                    if (!response.ok) throw new Error(`HTTP error fetching route! Status: ${response.status}`);
                    const gpxData = await response.text();
                    log('Route data received. Parsing...', 'success');
                    processSwcpData(gpxData, true);
                } catch(e) { log(`Failed to fetch map data: ${e.message}`, 'error'); }
            }

            function processSwcpData(data, isGpx = false) {
                try {
                    if (isGpx) {
                        if (typeof gpxParse === 'undefined') throw new Error('GPX-Parse library not loaded.');
                        gpxParse.parseGpx(data, (error, parsedData) => {
                            if (error) throw new Error(`GPX Parse Error: ${error}`);
                            const points = parsedData.tracks[0].segments[0].map(p => [p.lon, p.lat]);
                            swcpGeoJSON = turf.lineString(points);
                            localStorage.setItem(SWCP_DATA_KEY, JSON.stringify(swcpGeoJSON));
                            log('Map data parsed and saved to browser storage.', 'success');
                            renderMap();
                        });
                    } else {
                        swcpGeoJSON = JSON.parse(data);
                        renderMap();
                    }
                } catch(e) { log(`Error processing map data: ${e.message}`, 'error'); }
            }

            function renderMap() {
                if (!swcpGeoJSON || !map) return;
                 const leafletGeoJson = L.geoJSON(swcpGeoJSON, { style: { color: 'blue', weight: 3, opacity: 0.7 } }).addTo(map);
                map.fitBounds(leafletGeoJson.getBounds());
                swcpTotalDistance = turf.length(swcpGeoJSON, { units: 'kilometers' });
                totalDistanceEl.textContent = swcpTotalDistance.toFixed(2);
                analyzeButton.disabled = false;
                updateStravaButton.disabled = false;
            }
           
            function loadProgressFromStorage() {
                const completedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
                log(`Loaded ${completedPoints.length} completed points.`);
                updateProgress(completedPoints);
            }
           
            function resetProgress() {
                localStorage.removeItem(PROCESSED_ACTIVITIES_KEY);
                localStorage.removeItem(COMPLETED_POINTS_KEY);
                localStorage.removeItem(SWCP_DATA_KEY); // Also clear the map data to force a re-fetch
                log('Progress and map data reset. Please reload the page.', 'success');
                updateProgress([]);
            }

            async function analyzeAllActivities() {
                setLoading(true, 'analyze-button');
                const processedIds = new Set(JSON.parse(localStorage.getItem(PROCESSED_ACTIVITIES_KEY) || '[]'));
                const activities = await fetchAllActivities();
                if (!activities) { setLoading(false, 'analyze-button'); return; }

                const newActivities = activities.filter(a => !processedIds.has(a.id));
                if (newActivities.length === 0) {
                    log('No new activities to analyze.', 'info');
                    setLoading(false, 'analyze-button');
                    return;
                }

                log(`Analyzing ${newActivities.length} new activities...`);
                let newlyCompletedPoints = [];

                for (const activity of newActivities) {
                    log(`Checking: "${activity.name}"`);
                    await sleep(500);
                    const stream = await getActivityStream(activity.id);
                    if (stream) {
                        const activityLine = turf.lineString(stream.map(p => [p[1], p[0]]));
                        const matchedPoints = findOverlappingPoints(activityLine);
                        if (matchedPoints.length > 0) {
                            log(`-> Found ${matchedPoints.length} matching points.`, 'success');
                            newlyCompletedPoints.push(...matchedPoints);
                        }
                    }
                    processedIds.add(activity.id);
                }
               
                const oldCompletedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
                const allCompletedPoints = oldCompletedPoints.concat(newlyCompletedPoints);

                localStorage.setItem(COMPLETED_POINTS_KEY, JSON.stringify(allCompletedPoints));
                localStorage.setItem(PROCESSED_ACTIVITIES_KEY, JSON.stringify(Array.from(processedIds)));

                log('Analysis complete.', 'success');
                updateProgress(allCompletedPoints);
                setLoading(false, 'analyze-button');
            }

            async function updateStravaTitles() {
                setLoading(true, 'update-strava-button');
                const activities = await fetchAllActivities();
                if (!activities) { setLoading(false, 'update-strava-button'); return; }

                log(`Checking ${activities.length} total activities for title updates...`);
                for (const activity of activities) {
                    // Check if the activity route actually overlaps with the path before updating
                    const stream = await getActivityStream(activity.id);
                    if (stream) {
                        const activityLine = turf.lineString(stream.map(p => [p[1], p[0]]));
                        if (findOverlappingPoints(activityLine).length > 0) {
                            const cleanName = activity.name.replace(/SWCP \d+\.\d+% \| /g, ''); // Remove old percentage
                            const newTitle = `SWCP ${currentPercentage}% | ${cleanName}`;
                            if (activity.name !== newTitle) {
                                log(`Updating title for "${cleanName}"`);
                                await updateActivity(activity.id, newTitle);
                                await sleep(500);
                            } else {
                                log(`Skipping "${activity.name}", already up to date.`);
                            }
                        }
                    }
                }
                log('Finished updating Strava titles.', 'success');
                setLoading(false, 'update-strava-button');
            }

            async function updateActivity(id, newTitle, newDescription) {
                const accessToken = sessionStorage.getItem('stravaAccessToken');
                const payload = { name: newTitle };
                if (newDescription) payload.description = newDescription;

                try {
                    const response = await fetch(`https://www.strava.com/api/v3/activities/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
                        body: JSON.stringify(payload)
                    });
                     if (!response.ok) {
                        log(`Failed to update activity ${id}. Status: ${response.status}`, 'error');
                    }
                } catch(e) { log(`Error updating activity ${id}: ${e.message}`, 'error'); }
            }

            function setLoading(isLoading, buttonId) {
                 const button = document.getElementById(buttonId);
                 const textSpan = document.getElementById(buttonId.replace('-button', '-text'));
                 button.disabled = isLoading;
                 const originalText = buttonId === 'analyze-button' ? 'Analyze New Activities' : 'Update Strava Activity Titles';
                 textSpan.innerHTML = isLoading ? '<span class="loader"></span>Processing...' : originalText;
            }

            async function fetchAllActivities() {
                const accessToken = sessionStorage.getItem('stravaAccessToken');
                let allActivities = [];
                for (let page = 1; page < 10; page++) { // Limit to 10 pages for sanity
                    try {
                        const response = await fetch(`https://www.strava.com/api/v3/athlete/activities?page=${page}&per_page=100`, {
                            headers: { 'Authorization': `Bearer ${accessToken}` }
                        });
                        if (!response.ok) throw new Error(await response.text());
                        const activities = await response.json();
                        if (activities.length === 0) break;
                        allActivities.push(...activities);
                    } catch(e) {
                        log(`Failed to fetch activities: ${e.message}`, 'error');
                        return null;
                    }
                }
                return allActivities.filter(a => ['Walk', 'Hike'].includes(a.type));
            }

            async function getActivityStream(activityId) {
                const accessToken = sessionStorage.getItem('stravaAccessToken');
                try {
                    const response = await fetch(`https://www.strava.com/api/v3/activities/${activityId}/streams?keys=latlng&key_by_type=true`, {
                         headers: { 'Authorization': `Bearer ${accessToken}` }
                    });
                    if (!response.ok) return null;
                    return (await response.json()).latlng?.data;
                } catch (e) {
                    log(`Error fetching stream for activity ${activityId}: ${e.message}`, 'error');
                    return null;
                }
            }
           
            function findOverlappingPoints(activityLine) {
                const matchedPoints = [];
                if (!swcpGeoJSON) return [];
                for (const pointCoords of activityLine.geometry.coordinates) {
                     const point = turf.point(pointCoords);
                     const nearestPointOnLine = turf.nearestPointOnLine(swcpGeoJSON, point, {units: 'meters'});
                     if (turf.distance(point, nearestPointOnLine, {units: 'meters'}) < DISTANCE_THRESHOLD_METERS) {
                        matchedPoints.push(nearestPointOnLine.geometry.coordinates);
                     }
                }
                return matchedPoints;
            }

            function updateProgress(completedPoints) {
                completedSegmentsLayer.clearLayers();
                let totalCompletedDistance = 0;
               
                if (completedPoints.length > 1) {
                    const uniquePoints = completedPoints.reduce((acc, point) => {
                        if (!acc.some(p => turf.distance(turf.point(p), turf.point(point), {units: 'kilometers'}) < 0.02)) {
                            acc.push(point);
                        }
                        return acc;
                    }, []);
                   
                    uniquePoints.sort((a, b) => turf.nearestPointOnLine(swcpGeoJSON, a).properties.location - turf.nearestPointOnLine(swcpGeoJSON, b).properties.location);

                    if (uniquePoints.length > 1) {
                        const completedLine = turf.lineString(uniquePoints);
                        totalCompletedDistance = turf.length(completedLine, { units: 'kilometers' });
                        L.geoJSON(completedLine, { style: { color: 'green', weight: 5, opacity: 0.8 } }).addTo(completedSegmentsLayer);
                    }
                }
               
                currentPercentage = swcpTotalDistance > 0 ? ((totalCompletedDistance / swcpTotalDistance) * 100).toFixed(2) : 0;
                completedDistanceEl.textContent = totalCompletedDistance.toFixed(2);
                progressPercentageEl.textContent = `${currentPercentage}%`;
                progressBar.style.width = `${currentPercentage}%`;
            }

            init();
        });
    </script>
</body>
</html>
