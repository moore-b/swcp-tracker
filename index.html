<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SW Coast Path Tracker</title>
   
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="" defer></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js' defer></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { height: 500px; width: 100%; border-radius: 0.5rem; }
        .btn-strava { background-color: #FC5200; }
        .btn-strava:hover { background-color: #e04a00; }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 24px; height: 24px; animation: spin 1s linear infinite;
            display: inline-block; margin-right: 10px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">South West Coast Path Tracker</h1>
            <p class="mt-2 text-lg text-gray-600">Log your progress on the 630-mile journey.</p>
        </header>

        <main id="main-content">
            <div id="config-section" class="bg-white p-6 rounded-lg shadow-md mb-8">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-3">1. Connect to Strava</h2>
                <div class="space-y-4">
                    <div>
                        <label for="clientId" class="block text-sm font-medium text-gray-700">Client ID</label>
                        <input type="text" id="clientId" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                    <div>
                        <label for="clientSecret" class="block text-sm font-medium text-gray-700">Client Secret</label>
                        <input type="password" id="clientSecret" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                <button id="connect-button" class="mt-6 w-full btn-strava text-white font-bold py-3 px-4 rounded-lg transition" disabled>
                    Connect with Strava
                </button>
            </div>

            <div id="progress-section" class="hidden bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4 border-b pb-3">
                     <h2 class="text-2xl font-semibold">2. Your Progress</h2>
                     <div id="strava-user-info" class="text-right"></div>
                </div>
                <div class="mb-6">
                    <p class="text-lg">Overall Completion: <span id="progress-percentage" class="font-bold text-blue-600">0.00%</span></p>
                    <p class="text-sm text-gray-500">Completed Distance: <span id="completed-distance">0.00</span> km / <span id="total-distance">0.00</span> km</p>
                    <div class="w-full bg-gray-200 rounded-full h-4 mt-2">
                        <div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                </div>
                <h3 class="text-xl font-semibold mb-3">Map of the Path</h3>
                <div id="map"></div>
                <div class="flex space-x-4 mt-6">
                    <button id="analyze-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center" disabled>
                        <span id="analyze-button-text">Analyze New Activities</span>
                    </button>
                    <button id="reset-button" class="w-1/3 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg">
                        Reset Progress
                    </button>
                </div>
            </div>

            <div id="status-log-section" class="mt-8">
                <h3 class="text-xl font-semibold mb-2">Status Log</h3>
                <div id="status-log" class="bg-gray-900 text-white font-mono text-sm rounded-lg p-4 h-48 overflow-y-auto"></div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const SWCP_GEOJSON_URL = 'swcp.geojson';
            const DISTANCE_THRESHOLD_METERS = 100;
            const PROCESSED_ACTIVITIES_KEY = 'swcp_processed_activities';
            const COMPLETED_POINTS_KEY = 'swcp_completed_points';
           
            const clientIdInput = document.getElementById('clientId');
            const clientSecretInput = document.getElementById('clientSecret');
            const connectButton = document.getElementById('connect-button');
            const configSection = document.getElementById('config-section');
            const progressSection = document.getElementById('progress-section');
            const analyzeButton = document.getElementById('analyze-button');
            const analyzeButtonText = document.getElementById('analyze-button-text');
            const resetButton = document.getElementById('reset-button');
            const statusLog = document.getElementById('status-log');
            const stravaUserInfo = document.getElementById('strava-user-info');
            const progressBar = document.getElementById('progress-bar');
            const progressPercentage = document.getElementById('progress-percentage');
            const completedDistanceEl = document.getElementById('completed-distance');
            const totalDistanceEl = document.getElementById('total-distance');

            let map;
            let swcpGeoJSON;
            let swcpTotalDistance = 0;
            let completedSegmentsLayer;

            const log = (message, type = 'info') => {
                const now = new Date().toLocaleTimeString();
                const color = type === 'error' ? 'text-red-400' : (type === 'success' ? 'text-green-400' : 'text-gray-300');
                statusLog.innerHTML += `<p><span class="text-gray-500">${now}:</span> <span class="${color}">${message}</span></p>`;
                statusLog.scrollTop = statusLog.scrollHeight;
                if (type === 'error') console.error(message);
            };
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
           
            const init = async () => {
                log('Page and scripts loaded. Initializing app...');
               
                clientIdInput.addEventListener('input', checkInputs);
                clientSecretInput.addEventListener('input', checkInputs);
                connectButton.addEventListener('click', connectToStrava);
                resetButton.addEventListener('click', resetProgress);
                analyzeButton.addEventListener('click', analyzeAllActivities);
               
                clientIdInput.value = sessionStorage.getItem('stravaClientId') || '';
                clientSecretInput.value = sessionStorage.getItem('stravaClientSecret') || '';
                checkInputs();

                const urlParams = new URLSearchParams(window.location.search);
                const authCode = urlParams.get('code');

                if (authCode) {
                    await getAccessToken(authCode);
                } else if (sessionStorage.getItem('stravaAccessToken')) {
                    await showProgressSection();
                } else {
                    log('No access token. Please connect to Strava.');
                }
            };
           
            function checkInputs() {
                if (connectButton) {
                    connectButton.disabled = !(clientIdInput.value.trim() && clientSecretInput.value.trim());
                }
            }
       
            function connectToStrava() {
                sessionStorage.setItem('stravaClientId', clientIdInput.value.trim());
                sessionStorage.setItem('stravaClientSecret', clientSecretInput.value.trim());
                const redirectUri = window.location.origin + window.location.pathname;
                const scope = 'read,activity:read_all,activity:write';
                const authUrl = `https://www.strava.com/oauth/authorize?client_id=${clientIdInput.value.trim()}&redirect_uri=${redirectUri}&response_type=code&scope=${scope}`;
                window.location.href = authUrl;
            }

            async function getAccessToken(code) {
                log('Authorization code found. Exchanging for access token...');
                try {
                    const response = await fetch('https://www.strava.com/oauth/token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            client_id: sessionStorage.getItem('stravaClientId'),
                            client_secret: sessionStorage.getItem('stravaClientSecret'),
                            code: code,
                            grant_type: 'authorization_code',
                        }),
                    });
                    const data = await response.json();
                    if (data.access_token) {
                        log('Success! Access Token received.', 'success');
                        sessionStorage.setItem('stravaAccessToken', data.access_token);
                        sessionStorage.setItem('stravaAthlete', JSON.stringify(data.athlete));
                        window.location.href = window.location.pathname;
                    } else {
                        log(`Error getting access token: ${data.message}`, 'error');
                    }
                } catch (error) {
                    log(`Network error during token exchange: ${error.message}`, 'error');
                }
            }
           
            async function showProgressSection() {
                configSection.style.display = 'none';
                progressSection.style.display = 'block';

                const athlete = JSON.parse(sessionStorage.getItem('stravaAthlete') || '{}');
                if(athlete.firstname) {
                    stravaUserInfo.innerHTML = `<p class="font-semibold">${athlete.firstname} ${athlete.lastname}</p>`;
                }
                await initializeMap();
                loadProgressFromStorage();
            }

            async function initializeMap() {
                log('Initializing map...');
                map = L.map('map').setView([50.5, -4.0], 8);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                completedSegmentsLayer = L.layerGroup().addTo(map);

                log('Fetching SWCP route data from local GeoJSON file...');
                try {
                    const response = await fetch(SWCP_GEOJSON_URL);
                    if (!response.ok) throw new Error(`HTTP error! Could not find GeoJSON file. Status: ${response.status}`);
                   
                    const data = await response.json();
                    log('GeoJSON data loaded and parsed successfully.', 'success');
                   
                    swcpGeoJSON = data.geometry;
                    const leafletGeoJson = L.geoJSON(data, { style: { color: 'blue', weight: 3, opacity: 0.7 } }).addTo(map);
                    map.fitBounds(leafletGeoJson.getBounds());

                    swcpTotalDistance = turf.length(swcpGeoJSON, { units: 'kilometers' });
                    totalDistanceEl.textContent = swcpTotalDistance.toFixed(2);
                    analyzeButton.disabled = false;

                } catch(e) {
                    log(e.message, 'error');
                }
            }
           
            function loadProgressFromStorage() {
                const completedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
                log(`Loaded ${completedPoints.length} completed points from storage.`);
                updateProgress(completedPoints);
            }
           
            function resetProgress() {
                localStorage.removeItem(PROCESSED_ACTIVITIES_KEY);
                localStorage.removeItem(COMPLETED_POINTS_KEY);
                log('Progress has been reset.', 'success');
                updateProgress([]);
            }

            async function analyzeAllActivities() {
                log('Analysis started...');
                setLoading(true);
                const processedIds = new Set(JSON.parse(localStorage.getItem(PROCESSED_ACTIVITIES_KEY) || '[]'));
                log(`Found ${processedIds.size} previously processed activities.`);

                const activities = await fetchAllActivities();
                if (!activities) {
                    setLoading(false);
                    return;
                }

                const newActivities = activities.filter(a => !processedIds.has(a.id));
                if (newActivities.length === 0) {
                    log('No new walks or hikes found to analyze.', 'info');
                    setLoading(false);
                    return;
                }

                log(`Found ${newActivities.length} new activities to analyze...`);
                let newlyCompletedPoints = [];

                for (const activity of newActivities) {
                    log(`Analyzing: "${activity.name}" (ID: ${activity.id})`);
                    await sleep(500);
                    const stream = await getActivityStream(activity.id);
                    if (stream) {
                        const activityLine = turf.lineString(stream.map(p => [p[1], p[0]]));
                        const matchedPoints = findOverlappingPoints(activityLine);
                        if (matchedPoints.length > 0) {
                            log(`-> Found ${matchedPoints.length} matching points.`, 'success');
                            newlyCompletedPoints.push(...matchedPoints);
                        }
                    }
                    processedIds.add(activity.id);
                }
               
                const oldCompletedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
                const allCompletedPoints = oldCompletedPoints.concat(newlyCompletedPoints);

                localStorage.setItem(COMPLETED_POINTS_KEY, JSON.stringify(allCompletedPoints));
                localStorage.setItem(PROCESSED_ACTIVITIES_KEY, JSON.stringify(Array.from(processedIds)));

                log('Analysis complete. Updating map and progress.', 'success');
                updateProgress(allCompletedPoints);
                setLoading(false);
            }

            function setLoading(isLoading) {
                 analyzeButton.disabled = isLoading;
                 analyzeButtonText.innerHTML = isLoading ? '<span class="loader"></span>Analyzing...' : 'Analyze New Activities';
            }

            async function fetchAllActivities() {
                const accessToken = sessionStorage.getItem('stravaAccessToken');
                let allActivities = [];
                let page = 1;
                const perPage = 100;
                while(true) {
                    try {
                        const response = await fetch(`https://www.strava.com/api/v3/athlete/activities?page=${page}&per_page=${perPage}`, {
                            headers: { 'Authorization': `Bearer ${accessToken}` }
                        });
                        if (!response.ok) throw new Error(await response.text());
                        const activities = await response.json();
                        if (activities.length === 0) break;
                        allActivities.push(...activities);
                        page++;
                    } catch(e) {
                        log(`Failed to fetch activities: ${e.message}`, 'error');
                        return null;
                    }
                }
                return allActivities.filter(a => ['Walk', 'Hike'].includes(a.type));
            }

            async function getActivityStream(activityId) {
                const accessToken = sessionStorage.getItem('stravaAccessToken');
                try {
                    const response = await fetch(`https://www.strava.com/api/v3/activities/${activityId}/streams?keys=latlng&key_by_type=true`, {
                         headers: { 'Authorization': `Bearer ${accessToken}` }
                    });
                    if (!response.ok) return null;
                    const data = await response.json();
                    return data.latlng ? data.latlng.data : null;
                } catch (e) {
                    log(`Error fetching stream for activity ${activityId}: ${e.message}`, 'error');
                    return null;
                }
            }
           
            function findOverlappingPoints(activityLine) {
                const matchedPoints = [];
                if (!swcpGeoJSON) return [];
                for (const pointCoords of activityLine.geometry.coordinates) {
                     const point = turf.point(pointCoords);
                     const nearestPointOnLine = turf.nearestPointOnLine(swcpGeoJSON, point, {units: 'meters'});
                     if (turf.distance(point, nearestPointOnLine, {units: 'meters'}) < DISTANCE_THRESHOLD_METERS) {
                        matchedPoints.push(nearestPointOnLine.geometry.coordinates);
                     }
                }
                return matchedPoints;
            }

            function updateProgress(completedPoints) {
                completedSegmentsLayer.clearLayers();
                let totalCompletedDistance = 0;
                let percentage = 0;

                if (completedPoints.length > 1) {
                    const uniquePoints = completedPoints.reduce((acc, point) => {
                        if (!acc.some(p => turf.distance(turf.point(p), turf.point(point), {units: 'kilometers'}) < 0.02)) {
                            acc.push(point);
                        }
                        return acc;
                    }, []);
                   
                    uniquePoints.sort((a, b) => {
                        const locA = turf.nearestPointOnLine(swcpGeoJSON, a).properties.location;
                        const locB = turf.nearestPointOnLine(swcpGeoJSON, b).properties.location;
                        return locA - locB;
                    });

                    if (uniquePoints.length > 1) {
                        const completedLine = turf.lineString(uniquePoints);
                        totalCompletedDistance = turf.length(completedLine, { units: 'kilometers' });
                        L.geoJSON(completedLine, { style: { color: 'green', weight: 5, opacity: 0.8 } }).addTo(completedSegmentsLayer);
                        percentage = Math.min(100, (totalCompletedDistance / swcpTotalDistance) * 100);
                    }
                }
               
                completedDistanceEl.textContent = totalCompletedDistance.toFixed(2);
                progressPercentage.textContent = percentage.toFixed(2) + '%';
                progressBar.style.width = `${percentage}%`;
            }
            init();
        });
    </script>
</body>
</html>
