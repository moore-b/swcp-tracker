<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SW Coast Path Tracker</title>
   
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
   
    <!-- Leaflet.js for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
   
    <!-- GPX parsing library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gpx-parse/0.10.3/gpx-parse.min.js"></script>
   
    <!-- Turf.js for geographic calculations -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        #map {
            height: 500px;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .leaflet-control-zoom { border: 1px solid #ccc !important; }
        .btn-strava { background-color: #FC5200; }
        .btn-strava:hover { background-color: #e04a00; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
       
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">South West Coast Path Tracker</h1>
            <p class="mt-2 text-lg text-gray-600">Log your progress on the 630-mile journey.</p>
        </header>

        <main id="main-content">
           
            <div id="config-section" class="bg-white p-6 rounded-lg shadow-md mb-8">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-3">1. Connect to Strava</h2>
                <div class="space-y-4">
                    <div>
                        <label for="clientId" class="block text-sm font-medium text-gray-700">Client ID</label>
                        <input type="text" id="clientId" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                    <div>
                        <label for="clientSecret" class="block text-sm font-medium text-gray-700">Client Secret</label>
                        <input type="password" id="clientSecret" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                <button id="connect-button" class="mt-6 w-full btn-strava text-white font-bold py-3 px-4 rounded-lg transition" disabled>
                    Connect with Strava
                </button>
            </div>

            <div id="progress-section" class="hidden bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4 border-b pb-3">
                     <h2 class="text-2xl font-semibold">2. Your Progress</h2>
                     <div id="strava-user-info" class="text-right"></div>
                </div>
               
                <div class="mb-6">
                    <p class="text-lg">Overall Completion: <span id="progress-percentage" class="font-bold text-blue-600">0.00%</span></p>
                    <p class="text-sm text-gray-500">Completed Distance: <span id="completed-distance">0.00</span> km / <span id="total-distance">0.00</span> km</p>
                    <div class="w-full bg-gray-200 rounded-full h-4 mt-2">
                        <div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                </div>

                <h3 class="text-xl font-semibold mb-3">Map of the Path</h3>
                <div id="map"></div>
                <div class="flex space-x-4 mt-6">
                    <button id="analyze-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center disabled:bg-gray-400 disabled:cursor-not-allowed">
                        <span id="analyze-button-text">Analyze New Activities</span>
                    </button>
                    <button id="reset-button" class="w-1/3 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg">
                        Reset Progress
                    </button>
                </div>
            </div>

            <div id="status-log-section" class="mt-8">
                <h3 class="text-xl font-semibold mb-2">Status Log</h3>
                <div id="status-log" class="bg-gray-900 text-white font-mono text-sm rounded-lg p-4 h-48 overflow-y-auto"></div>
            </div>

        </main>
    </div>

    <script>
        // --- CONFIGURATION & CONSTANTS ---
        const SWCP_GPX_URL = './south-west-coast-path.gpx';
        const DISTANCE_THRESHOLD_METERS = 100;
        const PROCESSED_ACTIVITIES_KEY = 'swcp_processed_activities';
        const COMPLETED_POINTS_KEY = 'swcp_completed_points';
       
        // --- DOM ELEMENTS ---
        const clientIdInput = document.getElementById('clientId');
        const clientSecretInput = document.getElementById('clientSecret');
        const connectButton = document.getElementById('connect-button');
        const configSection = document.getElementById('config-section');
        const progressSection = document.getElementById('progress-section');
        const analyzeButton = document.getElementById('analyze-button');
        const analyzeButtonText = document.getElementById('analyze-button-text');
        const resetButton = document.getElementById('reset-button');
        const statusLog = document.getElementById('status-log');
        const stravaUserInfo = document.getElementById('strava-user-info');
        const progressBar = document.getElementById('progress-bar');
        const progressPercentage = document.getElementById('progress-percentage');
        const completedDistanceEl = document.getElementById('completed-distance');
        const totalDistanceEl = document.getElementById('total-distance');

        // --- GLOBAL STATE ---
        let map;
        let swcpGeoJSON;
        let swcpTotalDistance = 0;
        let completedSegmentsLayer;

        // --- HELPER FUNCTIONS ---
        const log = (message, type = 'info') => {
            const now = new Date().toLocaleTimeString();
            const color = type === 'error' ? 'text-red-400' : (type === 'success' ? 'text-green-400' : 'text-gray-300');
            statusLog.innerHTML += `<p><span class="text-gray-500">${now}:</span> <span class="${color}">${message}</span></p>`;
            statusLog.scrollTop = statusLog.scrollHeight;
        };
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- CORE LOGIC ---
        window.onload = async () => {
            try {
                log('Page loaded. Initializing...');
                clientIdInput.value = sessionStorage.getItem('stravaClientId') || '';
                clientSecretInput.value = sessionStorage.getItem('stravaClientSecret') || '';
                checkInputs();

                const urlParams = new URLSearchParams(window.location.search);
                const authCode = urlParams.get('code');

                if (authCode) {
                    log('Authorization code found. Getting access token...');
                    await getAccessToken(authCode);
                }
               
                if (sessionStorage.getItem('stravaAccessToken')) {
                    log('Access token found. Showing progress section.', 'success');
                    await showProgressSection();
                } else {
                    log('No access token. Please connect to Strava.');
                }
            } catch (e) {
                log(`A critical error occurred on page load: ${e.message}`, 'error');
            }
        };

        function checkInputs() {
            connectButton.disabled = !(clientIdInput.value.trim() && clientSecretInput.value.trim());
        }
        clientIdInput.addEventListener('input', checkInputs);
        clientSecretInput.addEventListener('input', checkInputs);
       
        // --- STRAVA AUTHENTICATION ---
        connectButton.addEventListener('click', () => {
            log('Connect button clicked! Preparing to redirect...');
            try {
                sessionStorage.setItem('stravaClientId', clientIdInput.value.trim());
                sessionStorage.setItem('stravaClientSecret', clientSecretInput.value.trim());
                const redirectUri = window.location.origin + window.location.pathname;
                const scope = 'read,activity:read_all,activity:write';
                const authUrl = `https://www.strava.com/oauth/authorize?client_id=${clientIdInput.value.trim()}&redirect_uri=${redirectUri}&response_type=code&scope=${scope}`;
                window.location.href = authUrl;
            } catch (e) {
                log(`An error occurred in the connect function: ${e.message}`, 'error');
            }
        });

        async function getAccessToken(code) {
            try {
                const response = await fetch('https://www.strava.com/oauth/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        client_id: sessionStorage.getItem('stravaClientId'),
                        client_secret: sessionStorage.getItem('stravaClientSecret'),
                        code: code,
                        grant_type: 'authorization_code',
                    }),
                });
                const data = await response.json();
                if (data.access_token) {
                    log('Success! Access Token received.', 'success');
                    sessionStorage.setItem('stravaAccessToken', data.access_token);
                    sessionStorage.setItem('stravaRefreshToken', data.refresh_token);
                    sessionStorage.setItem('stravaAthlete', JSON.stringify(data.athlete));
                    window.location.href = window.location.pathname;
                } else {
                    log(`Error getting access token: ${data.message}`, 'error');
                }
            } catch (error) {
                log(`Network error during token exchange: ${error.message}`, 'error');
            }
        }
       
        // --- UI AND MAP LOGIC ---
        async function showProgressSection() {
            configSection.style.display = 'none';
            progressSection.style.display = 'block';

            const athlete = JSON.parse(sessionStorage.getItem('stravaAthlete'));
            if(athlete) {
                stravaUserInfo.innerHTML = `<p class="font-semibold">${athlete.firstname} ${athlete.lastname}</p>`;
            }
            await initializeMap();
            loadProgressFromStorage();
        }

        async function initializeMap() {
            log('Initializing map...');
            map = L.map('map').setView([50.5, -4.0], 8);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            completedSegmentsLayer = L.layerGroup().addTo(map);

            log('Fetching SWCP route data from local file...');
            try {
                const response = await fetch(SWCP_GPX_URL);
                if (!response.ok) throw new Error(`HTTP error! Could not find GPX file. Did you upload it to GitHub? Status: ${response.status}`);
                const gpxData = await response.text();
                log('Route data received. Parsing GPX file...', 'success');
               
                return new Promise((resolve, reject) => {
                    gpxParse.parseGpx(gpxData, (error, data) => {
                        if (error) {
                            reject(new Error(`GPX Parse Error: ${error}`));
                            return;
                        }
                       
                        const points = data.tracks[0].segments[0].map(p => [p.lon, p.lat]);
                        swcpGeoJSON = turf.lineString(points);
                        swcpTotalDistance = turf.length(swcpGeoJSON, { units: 'kilometers' });
                        totalDistanceEl.textContent = swcpTotalDistance.toFixed(2);
                       
                        const leafletPoints = points.map(p => [p[1], p[0]]);
                        const swcpPolyline = L.polyline(leafletPoints, { color: 'blue', weight: 3, opacity: 0.7 }).addTo(map);
                        map.fitBounds(swcpPolyline.getBounds());
                        log('Path data loaded successfully.', 'success');
                        resolve();
                    });
                });
            } catch(e) {
                log(e.message, 'error');
            }
        }
       
        // --- DATA PERSISTENCE ---
        function loadProgressFromStorage() {
            const completedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
            log(`Loaded ${completedPoints.length} completed points from storage.`);
            updateProgress(completedPoints, false);
        }
       
        resetButton.addEventListener('click', () => {
            // ** FIX ** Removed unsupported 'confirm()' dialog which can break scripts.
            localStorage.removeItem(PROCESSED_ACTIVITIES_KEY);
            localStorage.removeItem(COMPLETED_POINTS_KEY);
            log('Progress has been reset. All activities will be re-analyzed on the next run.', 'success');
            updateProgress([], false);
        });

        // --- MAIN ANALYSIS LOGIC ---
        analyzeButton.addEventListener('click', analyzeAllActivities);

        async function analyzeAllActivities() {
            log('Analysis started...');
            setLoading(true);
           
            const processedIds = JSON.parse(localStorage.getItem(PROCESSED_ACTIVITIES_KEY) || '[]');
            log(`Found ${processedIds.length} previously processed activities.`);

            const activities = await fetchAllActivities();
            if (!activities) {
                setLoading(false);
                return;
            }

            const newActivities = activities.filter(a => !processedIds.includes(a.id));
            if (newActivities.length === 0) {
                log('No new walks or hikes found to analyze.', 'info');
                setLoading(false);
                return;
            }

            log(`Found ${newActivities.length} new activities to analyze...`);
            let newlyCompletedPoints = [];
            let newProcessedIds = [...processedIds];

            for (const activity of newActivities) {
                log(`Analyzing: "${activity.name}" (ID: ${activity.id})`);
                await sleep(500);
                const stream = await getActivityStream(activity.id);
                if (stream) {
                    const activityPoints = stream.map(p => [p[1], p[0]]);
                    const activityLine = turf.lineString(activityPoints);
                    const matchedPoints = findOverlappingPoints(activityLine);
                    if (matchedPoints.length > 0) {
                        log(`-> Found ${matchedPoints.length} matching points in this activity.`, 'success');
                        newlyCompletedPoints.push(...matchedPoints);
                    }
                }
                newProcessedIds.push(activity.id);
            }
           
            const oldCompletedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
            const allCompletedPoints = oldCompletedPoints.concat(newlyCompletedPoints);

            localStorage.setItem(COMPLETED_POINTS_KEY, JSON.stringify(allCompletedPoints));
            localStorage.setItem(PROCESSED_ACTIVITIES_KEY, JSON.stringify(newProcessedIds));

            log('Analysis complete. Updating map and progress.', 'success');
            updateProgress(allCompletedPoints, true);
            setLoading(false);
        }

        function setLoading(isLoading) {
             if (isLoading) {
                analyzeButton.disabled = true;
                analyzeButtonText.innerHTML = '<span class="loader"></span>Analyzing...';
            } else {
                analyzeButton.disabled = false;
                analyzeButtonText.innerHTML = 'Analyze New Activities';
            }
        }

        async function fetchAllActivities() {
            const accessToken = sessionStorage.getItem('stravaAccessToken');
            let allActivities = [];
            let page = 1;
            const perPage = 100;
           
            while(true) {
                try {
                    log(`Fetching activities page ${page}...`);
                    const response = await fetch(`https://www.strava.com/api/v3/athlete/activities?page=${page}&per_page=${perPage}`, {
                        headers: { 'Authorization': `Bearer ${accessToken}` }
                    });
                    if (!response.ok) throw new Error(await response.text());
                   
                    const activities = await response.json();
                    if (activities.length === 0) break;
                   
                    allActivities.push(...activities);
                    page++;
                } catch(e) {
                    log(`Failed to fetch activities: ${e.message}`, 'error');
                    return null;
                }
            }
            return allActivities.filter(a => ['Walk', 'Hike'].includes(a.type));
        }

        async function getActivityStream(activityId) {
            const accessToken = sessionStorage.getItem('stravaAccessToken');
            try {
                const response = await fetch(`https://www.strava.com/api/v3/activities/${activityId}/streams?keys=latlng&key_by_type=true`, {
                     headers: { 'Authorization': `Bearer ${accessToken}` }
                });
                if (!response.ok) return null;
                const data = await response.json();
                return data.latlng ? data.latlng.data : null;
            } catch (e) {
                log(`Error fetching stream for activity ${activityId}: ${e.message}`, 'error');
                return null;
            }
        }
       
        function findOverlappingPoints(activityLine) {
            const matchedPoints = [];
            for (const pointCoords of activityLine.geometry.coordinates) {
                 const point = turf.point(pointCoords);
                 const nearestPointOnLine = turf.nearestPointOnLine(swcpGeoJSON, point, {units: 'meters'});
                 if (turf.distance(point, nearestPointOnLine, {units: 'meters'}) < DISTANCE_THRESHOLD_METERS) {
                    matchedPoints.push(nearestPointOnLine.geometry.coordinates);
                 }
            }
            return matchedPoints;
        }

        function updateProgress(completedPoints, isNewAnalysis) {
            completedSegmentsLayer.clearLayers();
           
            let totalCompletedDistance = 0;
            let percentage = 0;

            if (completedPoints.length > 1) {
                const uniquePoints = completedPoints.reduce((
