<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SW Coast Path Tracker</title>

<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="" defer></script>
<script src='https://unpkg.com/@turf/turf@6/turf.min.js' defer></script>
<script src="https://unpkg.com/@mapbox/polyline@1.1.1/src/polyline.js"></script>


<style>
body {
font-family: 'Inter', sans-serif;
/* Remove background from body, it's now on #app-background div */
background-color: #f3f4f6; /* Fallback if image fails or for initial load */
}

#app-background {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-image: url('background.webp'); /* Updated to .webp */
background-size: cover;
background-position: center center;
background-repeat: no-repeat;
z-index: -1; /* Ensure it stays behind all content */
}

#map {
height: 700px;
width: 100%;
border-radius: 0.5rem;
position: relative; /* Essential for absolute positioning of overlay */
}
.activity-map { height: 200px; width: 100%;
border-radius: 0.5rem; background-color: #f3f4f6; }


/* Unified Button Styling */
.btn-base {
font-weight: 700; /* Equivalent to font-bold */
padding: 0.5rem 0.75rem;
/* py-2 px-3 */
border-radius: 0.5rem; /* rounded-lg */

/* All transformations, transitions, and shadows for consistent behavior */
transform-origin: center; /* Swell from center */
transition-property: all; /* Apply transition to all changing properties */
transition-duration: 300ms;
/* Equivalent to Tailwind's duration-300 */
transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* Equivalent to Tailwind's ease-in-out */
box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Equivalent to Tailwind's shadow-md */
outline: none;
/* Remove default outline */
border: none; /* Remove default border */
cursor: pointer; /* Ensure cursor is pointer */
}

.btn-base:hover {
transform: scale(1.05); /* Equivalent to Tailwind's hover:scale-105 */
box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Equivalent to Tailwind's hover:shadow-lg */
}

.btn-base:disabled {
background-color: #d1d5db; /* Equivalent to Tailwind's disabled:bg-gray-300 */
}

.btn-strava {
background-color: #FC5200; /* Strava Orange */
color: white;
}
.btn-strava:hover {
background-color: #e04a00;
/* Darker Strava Orange */
}
.btn-primary { /* For Analyze */
background-color: #3b82f6; /* Tailwind Blue-500 */
color: white;
}
.btn-primary:hover {
background-color: #2563eb;
/* Tailwind Blue-600 */
}
.btn-secondary { /* For Add to Description */
background-color: #10b981; /* Tailwind Emerald-500 */
color: white;
}
.btn-secondary:hover {
background-color: #059669;
/* Tailwind Emerald-600 */
}
.btn-danger { /* For Reset */
color: #ef4444; /* Tailwind Red-500 */
}

.btn-danger:hover {
color: #dc2626; /* Tailwind Red-600 */
text-decoration: underline;
}


.loader {
border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
border-radius: 50%;
width: 24px; height: 24px;
animation: spin 1s linear infinite;
display: inline-block; margin-right: 10px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg);
} }

.filter-btn {
padding: 0.5rem 1rem;
border: 1px solid #d1d5db;
border-radius: 0.5rem;
background-color: #ffffff;
transition: background-color 0.2s;
}

.filter-btn:hover {
background-color: #f3f4f6;
}

.filter-btn.active {
background-color: #3b82f6;
color: #ffffff;
border-color: #3b82f6;
}


/* --- Translucent & Blurred Tile Backgrounds --- */
.blurred-tile-background {
 background-color: rgba(192, 192, 192, 0.4) !important; /* Grey tint with 40% opacity, !important to ensure it applies */
backdrop-filter: blur(5px); /* Adjusted blur amount to 5px for more distinctness */
-webkit-backdrop-filter: blur(5px);
/* For Safari compatibility */
box-shadow: 0 12px 20px -3px rgba(0, 0, 0, 0.2), 0 6px 10px -2px rgba(0, 0, 0, 0.1); /* More pronounced shadow */
}

/* --- CSS Grid Layout --- */
#main-layout-container {
display: grid;
/* Desktop: 2 columns (Map/Status stack: 2fr | Activities: 1fr) */
grid-template-columns: 2fr 1fr;
grid-template-rows: auto auto auto; /* Rows for Header, Map, and Status Log */
gap: 1rem; /* Increased gap for more breathing room */
min-height: 100vh;
padding: 1rem; /* Padding around the whole grid to ensure borders are visible */
}


/* Placement of items within the main grid for desktop */
#header-tile { /* New header tile */
grid-column: 1;
grid-row: 1;
}
#center-column { /* This is the Map and its related content */
grid-column: 1;
grid-row: 2;
}
#left-column { /* This is the Status Log */
grid-column: 1;
grid-row: 3;
}
#right-column { /* This is the Activities List */
grid-column: 2;
grid-row: 1 / span 3; /* Spans all 3 rows */
}

/* For smaller screens, stack columns vertically */
@media (max-width: 767px) { /* md breakpoint for stacking */
#main-layout-container {
grid-template-columns: 1fr;
/* Single column layout for smaller screens */
grid-template-rows: auto auto auto auto; /* Stack Header, Map content, Activities, Status Log */
padding: 1rem; /* More padding on mobile */
}

/* Reorder for mobile: Map first, then Activities, then Status Log */
#header-tile {
grid-row: 1;
}
#center-column {
grid-row: 2;
padding: 1rem; /* Adjust padding for mobile */
}
#right-column {
grid-column: 1; /* Ensure it's in the single column */
grid-row: 3;
height: auto; /* Remove h-screen for stacking */
position: static; /* Remove sticky for stacking */
overflow-y: visible;
/* Allow normal scrolling */
padding: 1rem; /* Adjust padding for mobile */
}
#left-column { /* Status log now comes last on mobile */
grid-column: 1;
grid-row: 4;
height: auto;
position: static;
overflow-y: visible;
padding: 1rem; /* Adjust padding for mobile */
}
}


/* Status log details summary styling for expand/collapse indicator */
#status-log-details > summary {
cursor: pointer;
list-style: none; /* Remove default marker */
position: sticky;
top: 0;
background-color: inherit;
/* Ensure background color matches parent */
z-index: 10; /* Keep it above scrolling content */
}
#status-log-details > summary::-webkit-details-marker {
display: none;
}
#status-log-details > summary::before {
content: '+ ';
/* Custom expand indicator */
margin-right: 0.5rem;
display: inline-block;
transition: transform 0.2s;
}
#status-log-details[open] > summary::before {
content: '- '; /* Custom collapse indicator */
transform: rotate(0deg);
/* No rotation needed for +/- */
}


/* --- Custom Scrollbar Styles (Webkit browsers like Chrome, Safari, Edge) --- */
/* Thin scrollbar for the entire body */
body::-webkit-scrollbar {
width: 8px;
}
body::-webkit-scrollbar-track {
background: #f1f1f1; /* Light grey track */
}
body::-webkit-scrollbar-thumb {
background-color: #888;
border-radius: 4px;
}
body::-webkit-scrollbar-thumb:hover {
background-color: #555;
}

/* Less noticeable scrollbars for internal scrollable divs */
#left-column::-webkit-scrollbar,
#status-log::-webkit-scrollbar,
#right-column::-webkit-scrollbar,
#activity-list-container::-webkit-scrollbar {
width: 6px; /* Thinner scrollbar */
}
#left-column::-webkit-scrollbar-track,
#status-log::-webkit-scrollbar-track,
#right-column::-webkit-scrollbar-track,
#activity-list-container::-webkit-scrollbar-track {
background: transparent;
/* Invisible track */
}
#left-column::-webkit-scrollbar-thumb,
#status-log::-webkit-scrollbar-thumb,
#right-column::-webkit-scrollbar-thumb,
#activity-list-container::-webkit-scrollbar-thumb {
background-color: rgba(136, 136, 136, 0.5); /* Semi-transparent thumb */
border-radius: 3px;
}
#left-column::-webkit-scrollbar-thumb:hover,
#status-log::-webkit-scrollbar-thumb:hover,
#right-column::-webkit-scrollbar-thumb:hover,
#activity-list-container::-webkit-scrollbar-thumb:hover {
background-color: rgba(85, 85, 85, 0.7);
/* Darker on hover */
}
</style>

</head>
<body class="bg-gray-50 text-gray-800">

<div id="app-background"></div>

<div id="login-screen-wrapper" class="min-h-screen flex items-center justify-center">
<div id="config-section" class="p-8 rounded-lg shadow-xl max-w-md w-full text-center blurred-tile-background">
<h2 class="text-3xl font-bold text-gray-900 mb-6 border-b pb-4">Connect to Strava</h2>
<div class="space-y-4 mb-6">
<div><label for="clientId" class="block text-sm font-medium text-gray-700 text-left">Client ID</label><input type="text" id="clientId" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring focus:ring-blue-200 focus:border-blue-500"></div>
<div><label for="clientSecret" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring focus:ring-blue-200 focus:border-blue-500">Client Secret</label><input type="password" id="clientSecret" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring focus:ring-blue-200 focus:border-blue-500"></div>
</div>
<button id="connect-button" class="w-full btn-base btn-strava">Connect with Strava</button>
</div>
</div>

<div id="main-layout-container" class="hidden">

<div id="header-tile" class="p-6 rounded-lg shadow-lg text-center blurred-tile-background">
<h1 class="text-4xl font-bold text-gray-900">
South West Coast Path Tracker
</h1>
</div>

<div id="center-column" class="p-6 rounded-lg shadow-lg blurred-tile-background">
<div id="progress-section" class="hidden p-6 rounded-lg shadow-md">
<div class="flex justify-between items-center mb-4 border-b pb-3">
<h2 class="text-2xl font-semibold">Overall Progress</h2>
<div id="strava-user-info" class="text-right"></div>
</div>
<div class="mb-6">
<p class="text-lg">Completion: <span id="progress-percentage" class="font-bold text-blue-600">0.00%</span></p>
<p class="text-sm text-gray-500">Distance: <span id="completed-distance" style="color: #4A4A4A;">0.00</span> km / <span id="total-distance" style="color: #4A4A4A;">0.00</span> km</p>
<div class="w-full bg-gray-200 rounded-full h-4 mt-2"><div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-500" style="width: 0%"></div></div>
</div>
<h3 class="text-xl font-semibold mb-3">Master Map</h3>
<div id="map">
<div id="map-loading-overlay" class="absolute top-0 left-0 w-full h-full bg-white bg-opacity-80 flex justify-center items-center z-1000">
<div class="loader mr-3"></div> <span class="text-gray-500">Loading map...</span>
</div>
</div>
<div class="text-right mt-2"><button id="reset-button" class="text-sm btn-danger">Reset All Progress</button></div>
</div>
</div>

<div id="left-column" class="p-6 rounded-lg shadow-lg text-gray-800 blurred-tile-background">
<details open id="status-log-details" class="h-full flex flex-col">
<summary class="text-xl font-semibold p-4 sticky top-0 blurred-tile-background z-10">Status Log</summary>
<div id="status-log" class="flex-grow overflow-y-auto"></div>
</details>
</div>

<div id="right-column" class="p-6 rounded-lg shadow-lg text-gray-800 flex flex-col blurred-tile-background">
<div class="flex justify-between items-center mb-4 border-b pb-3">
<h2 class="text-2xl font-semibold">Activities</h2>
<div class="relative"><input type="text" id="activity-search" placeholder="Search activities..." class="px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring focus:ring-blue-200 focus:border-blue-500 w-40 text-sm"></div>
</div>
<div id="activity-filters" class="flex flex-wrap gap-2 mb-4"><button class="filter-btn active" data-filter="all">All</button><button class="filter-btn" data-filter="Hike">Hikes</button><button class="filter-btn" data-filter="Ride">Rides</button><button class="filter-btn" data-filter="Run">Runs</button><button class="filter-btn" data-filter="Walk">Walks</button></div>
<div id="activity-list-container" class="flex-grow overflow-y-auto space-y-4"></div>
</div>

</div> <script>
// --- Constants ---
const SWCP_GEOJSON_URL = 'swcp.geojson'; // Make sure this path is correct relative to index.html
const PROCESSED_ACTIVITIES_KEY = 'stravaProcessedActivities';
const COMPLETED_POINTS_KEY = 'swcpCompletedPoints';
const CACHED_ACTIVITIES_KEY = 'stravaCachedActivities';
const CACHED_ACTIVITIES_TIMESTAMP_KEY = 'stravaActivitiesCacheTimestamp';
const CACHE_EXPIRY_MS = 12 * 60 * 60 * 1000; // 12 hours for activity cache

// --- NEW Constants for Token Management ---
const TOKEN_URL = 'https://www.strava.com/oauth/token'; // Strava's token exchange endpoint
const API_BASE_URL = 'https://www.strava.com/api/v3'; // Base URL for Strava API requests

const ACCESS_TOKEN_KEY = 'stravaAccessToken'; // Key for session storage
const REFRESH_TOKEN_KEY = 'stravaRefreshToken'; // Key for local storage
const ACCESS_TOKEN_EXPIRY_KEY = 'stravaAccessTokenExpiry'; // New: To store expiry timestamp (in localStorage)


// --- Global Variables (Initialize empty or null) ---
let mainMap;
let completedSegmentsLayer; // Leaflet layer group for completed segments
let swcpGeoJSON; // Stores the GeoJSON of the SWCP
let swcpTotalDistance = 0; // Total distance of the SWCP
let allFetchedActivities = []; // Cache for all activities fetched from Strava
let analysisWorker = null; // Web Worker instance
let processedCompletedPoints = []; // Holds the result from the web worker

// --- UI Element References (Caching DOM elements) ---
const UIElements = {}; // Object to hold all UI element references

function cacheUIElements() {
    UIElements.loginScreenWrapper = document.getElementById('login-screen-wrapper');
    UIElements.configSection = document.getElementById('config-section');
    UIElements.clientId = document.getElementById('clientId');
    UIElements.clientSecret = document.getElementById('clientSecret');
    UIElements.connectButton = document.getElementById('connect-button');
    UIElements.mainLayoutContainer = document.getElementById('main-layout-container');
    UIElements.progressSection = document.getElementById('progress-section');
    UIElements.stravaUserInfo = document.getElementById('strava-user-info');
    UIElements.progressPercentage = document.getElementById('progress-percentage');
    UIElements.completedDistance = document.getElementById('completed-distance');
    UIElements.totalDistance = document.getElementById('total-distance');
    UIElements.progressBar = document.getElementById('progress-bar');
    UIElements.mainMap = document.getElementById('map'); // The main map div
    UIElements.mapLoadingOverlay = document.getElementById('map-loading-overlay');
    UIElements.resetButton = document.getElementById('reset-button');
    UIElements.statusLog = document.getElementById('status-log');
    UIElements.statusLogDetails = document.getElementById('status-log-details');
    UIElements.activityListContainer = document.getElementById('activity-list-container');
    UIElements.activitySearchBox = document.getElementById('activity-search');
    UIElements.filterButtons = document.getElementById('activity-filters');
    UIElements.appBackground = document.getElementById('app-background');
}

// --- Helper Functions ---

// Simple logging utility
function log(message, type = 'info') {
    const logElement = UIElements.statusLog;
    if (!logElement) {
        console.log(`Log (${type}): ${message}`);
        return;
    }
    const p = document.createElement('p');
    const timestamp = new Date().toLocaleTimeString();
    p.textContent = `[${timestamp}] ${message}`;
    p.classList.add('py-1', 'px-2', 'rounded-md', 'text-sm', 'mb-1'); // Tailwind classes

    switch (type) {
        case 'success':
            p.classList.add('bg-green-100', 'text-green-800');
            break;
        case 'error':
            p.classList.add('bg-red-100', 'text-red-800');
            break;
        case 'warn':
            p.classList.add('bg-yellow-100', 'text-yellow-800');
            break;
        case 'info':
        default:
            p.classList.add('bg-blue-100', 'text-blue-800');
            break;
    }
    logElement.prepend(p); // Add to top
    // Optional: Keep log short to avoid performance issues
    if (logElement.children.length > 50) {
        logElement.removeChild(logElement.lastChild);
    }
}

// Sleep function for delays
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// --- Strava Authentication Functions ---

// This function generates the Strava OAuth URL
function getStravaAuthUrl() {
    const clientId = UIElements.clientId.value || localStorage.getItem('stravaClientId');
    const redirectUri = window.location.origin; // Your app's base URL
    const scope = 'activity:read_all,profile:read_all'; // Request necessary scopes

    if (!clientId) {
        alert('Please enter your Strava Client ID.');
        return null;
    }

    // Force approval_prompt to 'force' to ensure user always sees the auth screen
    // This is good for development/testing, but for production, 'auto' might be better
    // to avoid unnecessary prompts if user already authorized.
    return `https://www.strava.com/oauth/authorize?client_id=${clientId}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&approval_prompt=force&scope=${scope}`;
}

// --- NEW TOKEN REFRESH LOGIC ---

async function refreshAccessToken() {
    log('Attempting to refresh access token...', 'info');
    const refreshToken = localStorage.getItem(REFRESH_TOKEN_KEY);
    const clientId = localStorage.getItem('stravaClientId');
    const clientSecret = localStorage.getItem('stravaClientSecret');

    if (!refreshToken || !clientId || !clientSecret) {
        log('Missing refresh token, client ID, or client secret. Cannot refresh. Forcing re-login.', 'error');
        // Clear tokens if we can't refresh
        sessionStorage.removeItem(ACCESS_TOKEN_KEY);
        localStorage.removeItem(REFRESH_TOKEN_KEY);
        localStorage.removeItem(ACCESS_TOKEN_EXPIRY_KEY);
        // Redirect to auth to get new tokens
        window.location.href = getStravaAuthUrl();
        throw new Error('Missing credentials for token refresh, redirecting to authentication.');
    }

    try {
        const response = await fetch(TOKEN_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                client_id: clientId,
                client_secret: clientSecret,
                grant_type: 'refresh_token',
                refresh_token: refreshToken
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            log(`Token refresh failed: ${errorData.message || response.statusText}. Forcing re-login.`, 'error');
            // If refresh fails, tokens are probably invalid/revoked, force re-login
            sessionStorage.removeItem(ACCESS_TOKEN_KEY);
            localStorage.removeItem(REFRESH_TOKEN_KEY);
            localStorage.removeItem(ACCESS_TOKEN_EXPIRY_KEY);
            window.location.href = getStravaAuthUrl(); // Redirect to auth
            throw new Error('Failed to refresh token, forcing re-authentication.');
        }

        const data = await response.json();
        log('Access token refreshed successfully!', 'success');

        const now = Date.now();
        const expiresInMs = data.expires_in * 1000;
        const expiryTime = now + expiresInMs - (5 * 60 * 1000); // 5 min buffer

        sessionStorage.setItem(ACCESS_TOKEN_KEY, data.access_token);
        localStorage.setItem(REFRESH_TOKEN_KEY, data.refresh_token); // Refresh token can also change
        localStorage.setItem(ACCESS_TOKEN_EXPIRY_KEY, expiryTime.toString());

        return data.access_token;

    } catch (e) {
        log(`Error during token refresh process: ${e.message}`, 'error');
        // This catch block handles network errors during fetch
        // If the refresh failed due to server error or network, still force re-login
        sessionStorage.removeItem(ACCESS_TOKEN_KEY);
        localStorage.removeItem(REFRESH_TOKEN_KEY);
        localStorage.removeItem(ACCESS_TOKEN_EXPIRY_KEY);
        window.location.href = getStravaAuthUrl();
        throw e; // Re-throw to propagate the error
    }
}

// Wrapper function for all Strava API calls
async function makeStravaApiRequest(endpoint, options = {}) {
    let accessToken = sessionStorage.getItem(ACCESS_TOKEN_KEY);
    let tokenExpiry = parseInt(localStorage.getItem(ACCESS_TOKEN_EXPIRY_KEY) || '0');
    const now = Date.now();

    // 1. Check if token needs refreshing
    if (!accessToken || now >= tokenExpiry) {
        log('Access token is missing or expired, attempting to refresh...', 'info');
        try {
            accessToken = await refreshAccessToken();
            if (!accessToken) { // refreshAccessToken might redirect and not return token
                return null;
            }
        } catch (e) {
            log('Failed to get a valid access token after refresh attempt. User might need to re-authenticate.', 'error');
            // refreshAccessToken will have handled redirect if needed.
            // Just return null to signal failure for this specific request.
            return null;
        }
    }

    // 2. Prepare headers for the request
    const headers = {
        ...options.headers, // Merge with any existing headers
        'Authorization': `Bearer ${accessToken}`
    };

    // 3. Make the request
    try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, { ...options, headers });

        if (!response.ok) {
            // Specifically handle 401 Unauthorized errors
            if (response.status === 401) {
                log('Received 401 Unauthorized. Token might be invalid despite checks, attempting refresh and retry...', 'warn');
                try {
                    // Attempt to refresh and retry ONE more time
                    accessToken = await refreshAccessToken(); // This will also handle redirects if fails
                    if (!accessToken) { // If refreshAccessToken redirected or threw, it returned null
                        log('Re-authentication required after second 401: Token refresh failed.', 'error');
                        throw new Error('Re-authentication required after second 401.');
                    }
                    // Retry the original request with the new token
                    const retryHeaders = {
                        ...options.headers,
                        'Authorization': `Bearer ${accessToken}`
                    };
                    const retryResponse = await fetch(`${API_BASE_URL}${endpoint}`, { ...options, headers: retryHeaders });
                    if (!retryResponse.ok) {
                        const errorData = await retryResponse.json();
                        throw new Error(`API retry failed with status ${retryResponse.status}: ${errorData.message || retryResponse.statusText}`);
                    }
                    return retryResponse; // Return the successful retry response

                } catch (e) {
                    log(`Failed to refresh token and retry after 401: ${e.message}`, 'error');
                    throw e; // Propagate error, likely leading to re-login
                }
            } else {
                // For other non-2xx errors, just throw the original error
                const errorData = await response.json();
                throw new Error(`API request failed with status ${response.status}: ${errorData.message || response.statusText}`);
            }
        }
        return response; // Return the successful response

    } catch (e) {
        log(`Error in makeStravaApiRequest for ${endpoint}: ${e.message}`, 'error');
        throw e; // Propagate the error
    }
}


// --- Main Application Flow ---

async function handleStravaCallback() {
    log('Handling Strava callback...', 'info');
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const error = urlParams.get('error');

    if (error) {
        log(`Strava authorization denied: ${error}`, 'error');
        // Clear tokens if auth was denied
        sessionStorage.removeItem(ACCESS_TOKEN_KEY);
        localStorage.removeItem(REFRESH_TOKEN_KEY);
        localStorage.removeItem(ACCESS_TOKEN_EXPIRY_KEY);
        UIElements.loginScreenWrapper.classList.remove('hidden');
        UIElements.mainLayoutContainer.classList.add('hidden');
        return;
    }

    if (code) {
        log('Authorization code received, exchanging for token...', 'info');
        const clientId = UIElements.clientId.value || localStorage.getItem('stravaClientId');
        const clientSecret = UIElements.clientSecret.value || localStorage.getItem('stravaClientSecret');
        const redirectUri = window.location.origin; // Assuming your app's root is the redirect URI

        if (!clientId || !clientSecret) {
            log('Client ID or Client Secret not found. Please enter them.', 'error');
            UIElements.loginScreenWrapper.classList.remove('hidden');
            UIElements.mainLayoutContainer.classList.add('hidden');
            return;
        }

        try {
            const response = await fetch(TOKEN_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    client_id: clientId,
                    client_secret: clientSecret,
                    code: code,
                    grant_type: 'authorization_code',
                    redirect_uri: redirectUri // Make sure this matches your registered redirect URI
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Failed to exchange code for token: ${errorData.message || response.statusText}`);
            }

            const data = await response.json();
            log('Token exchange successful!', 'success');

            const now = Date.now(); // Current time in milliseconds
            const expiresInMs = data.expires_in * 1000; // Convert seconds to milliseconds
            const expiryTime = now + expiresInMs - (5 * 60 * 1000); // Set expiry 5 minutes early for buffer

            sessionStorage.setItem(ACCESS_TOKEN_KEY, data.access_token);
            localStorage.setItem(REFRESH_TOKEN_KEY, data.refresh_token);
            localStorage.setItem(ACCESS_TOKEN_EXPIRY_KEY, expiryTime.toString()); // Store expiry timestamp

            // Store client ID and secret for future use (if you want to persist them)
            localStorage.setItem('stravaClientId', clientId);
            localStorage.setItem('stravaClientSecret', clientSecret);


            // Clean up URL parameters
            const cleanUrl = window.location.origin + window.location.pathname;
            window.history.replaceState({}, document.title, cleanUrl);

            await initializeApp(); // Proceed with app initialization
        } catch (e) {
            log(`Authentication failed: ${e.message}`, 'error');
            alert(`Authentication failed: ${e.message}`);
            UIElements.loginScreenWrapper.classList.remove('hidden');
            UIElements.mainLayoutContainer.classList.add('hidden');
            // Clear potentially bad tokens
            sessionStorage.removeItem(ACCESS_TOKEN_KEY);
            localStorage.removeItem(REFRESH_TOKEN_KEY);
            localStorage.removeItem(ACCESS_TOKEN_EXPIRY_KEY);
        }
    } else {
        log('No authorization code found in URL. Displaying login screen.', 'info');
        UIElements.loginScreenWrapper.classList.remove('hidden');
        UIElements.mainLayoutContainer.classList.add('hidden');
    }
}


// Initialize Application function
async function initializeApp() {
    cacheUIElements(); // Ensure UI elements are cached

    // Check if we have a token (either current or refreshable)
    const accessToken = sessionStorage.getItem(ACCESS_TOKEN_KEY);
    const refreshToken = localStorage.getItem(REFRESH_TOKEN_KEY);
    const tokenExpiry = parseInt(localStorage.getItem(ACCESS_TOKEN_EXPIRY_KEY) || '0');
    const now = Date.now();

    if (accessToken && now < tokenExpiry) {
        log('Access token found and valid. Proceeding to app.', 'success');
        UIElements.loginScreenWrapper.classList.add('hidden');
        UIElements.mainLayoutContainer.classList.remove('hidden');
        UIElements.progressSection.classList.remove('hidden');
        await loadMapAndSWCPData();
        await loadActivitiesAndProgress();
    } else if (refreshToken) {
        log('Access token expired or missing, but refresh token found. Attempting refresh...', 'info');
        try {
            await refreshAccessToken(); // This will store new token and expiry if successful
            // If refreshAccessToken succeeds, it means we now have a valid access token.
            // Recurse initializeApp to proceed with the main app flow.
            await initializeApp();
        } catch (e) {
            log('Failed to refresh token during app initialization. User needs to re-authenticate.', 'error');
            // If refreshAccessToken fails, it already redirects to getStravaAuthUrl
            // or throws an error. Just ensure login screen is visible.
            UIElements.loginScreenWrapper.classList.remove('hidden');
            UIElements.mainLayoutContainer.classList.add('hidden');
        }
    }
    else {
        log('No valid access token or refresh token found. Displaying login screen.', 'info');
        UIElements.loginScreenWrapper.classList.remove('hidden');
        UIElements.mainLayoutContainer.classList.add('hidden');

        // Restore Client ID/Secret if saved from previous session
        const savedClientId = localStorage.getItem('stravaClientId');
        const savedClientSecret = localStorage.getItem('stravaClientSecret');
        if (savedClientId) UIElements.clientId.value = savedClientId;
        if (savedClientSecret) UIElements.clientSecret.value = savedClientSecret;
    }
}

// Load Activities and Progress function
async function loadActivitiesAndProgress() {
    log('Loading activities and processing progress...', 'info');
    try {
        UIElements.stravaUserInfo.innerHTML = '<span class="text-gray-500 loader"></span> Loading user info...';
        // Get athlete profile
        const athleteResponse = await makeStravaApiRequest('/athlete');
        if (!athleteResponse) { /* makeStravaApiRequest handled redirect */ return; }
        const athleteData = await athleteResponse.json();
        UIElements.stravaUserInfo.innerHTML = `Connected as: <span class="font-bold">${athleteData.firstname} ${athleteData.lastname}</span>`;
        log(`Connected as: ${athleteData.firstname} ${athleteData.lastname}`, 'success');

        const activities = await fetchAllActivities(); // This now uses the wrapper
        await processActivities(activities);
        renderActivities(allFetchedActivities); // Render all activities after processing
        loadProgressFromStorage(); // Load existing progress for display
    } catch (e) {
        log(`Error loading activities or progress: ${e.message}`, 'error');
        // Specific error handling based on the error message from makeStravaApiRequest
        if (e.message.includes('re-authentication required')) {
            alert("Your Strava session has expired. Please reconnect.");
        } else {
            alert("An error occurred loading your data. Please check the log for details.");
        }
        UIElements.loginScreenWrapper.classList.remove('hidden'); // Show login screen on critical error
        UIElements.mainLayoutContainer.classList.add('hidden');
    }
}


// Load Map and SWCP Data function
async function loadMapAndSWCPData() {
    log('Loading map and SWCP data...', 'info');
    if (UIElements.mapLoadingOverlay) {
        UIElements.mapLoadingOverlay.style.display = 'flex';
        log('Map loading overlay displayed.', 'info');
        // Add a very small delay to allow browser to render the display:flex change
        await sleep(50); // Pause briefly
    }


    // Ensure map element exists before trying to create map
    if (!UIElements.mainMap) {
        log("Error: Map element not found!", "error");
        throw new Error("Map element not found");
    }
    mainMap = L.map(UIElements.mainMap).setView([50.5, -4.0], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(mainMap);
    completedSegmentsLayer = L.layerGroup().addTo(mainMap);

    log('Fetching SWCP route from your GeoJSON file...');
    try {
        const response = await fetch(SWCP_GEOJSON_URL);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (!data.features || data.features.length === 0) throw new Error('GeoJSON file is empty or invalid.');

        swcpTotalDistance = 0;
        const allCoordinates = data.features.reduce((coords, feature) => {
            if (feature.geometry.type === 'LineString') {
                swcpTotalDistance += turf.length(feature, { units: 'kilometers' });
                return coords.concat(feature.geometry.coordinates);
            } else if (feature.geometry.type === 'MultiLineString') {
                feature.geometry.coordinates.forEach(lineCoords => {
                    const line = turf.lineString(lineCoords);
                    swcpTotalDistance += turf.length(line, { units: 'kilometers' });
                    coords.push(...lineCoords);
                });
                return coords;
            }
            return coords;
        }, []);

        swcpGeoJSON = turf.lineString(allCoordinates).geometry;

        // Send SWCP GeoJSON to the worker for initial setup
        if (analysisWorker) {
            analysisWorker.postMessage({ type: 'init_swcp', swcpGeoJSONString: JSON.stringify(swcpGeoJSON) });
            log('SWCP GeoJSON sent to worker for initialization.');
        }

        const leafletGeoJson = L.geoJSON(data, { style: { color: 'blue', weight: 3, opacity: 0.7 } }).addTo(mainMap);
        mainMap.fitBounds(leafletGeoJson.getBounds());
        UIElements.totalDistance.textContent = swcpTotalDistance.toFixed(2);
        log('Master map loaded.', 'success');
    } catch(e) {
        log(`Failed to load map data: ${e.message}`, 'error');
        throw e;
    } finally {
        // Ensure overlay is hidden even on error
        if (UIElements.mapLoadingOverlay) {
            UIElements.mapLoadingOverlay.style.display = 'none';
            log('Map loading overlay hidden.', 'info');
        }
    }
}

// Load Progress From Storage function
function loadProgressFromStorage() {
    const completedPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');
    log(`Loaded ${completedPoints.length} completed points from storage.`);
    updateProgress(completedPoints);
}

// Reset Progress function
function resetProgress() {
    if (confirm("Are you sure you want to reset all progress? This cannot be undone.")) {
        localStorage.removeItem(PROCESSED_ACTIVITIES_KEY);
        localStorage.removeItem(COMPLETED_POINTS_KEY);
        // Clear cached activities and their timestamp
        localStorage.removeItem(CACHED_ACTIVITIES_KEY);
        localStorage.removeItem(CACHED_ACTIVITIES_TIMESTAMP_KEY);

        for (let i = localStorage.length - 1; i >= 0; i--) {
            const key = localStorage.key(i);
            if (key.startsWith(ACTIVITY_STREAMS_CACHE_PREFIX)) { // Assuming ACTIVITY_STREAMS_CACHE_PREFIX is defined
                localStorage.removeItem(key);
            }
        }
        log('Progress, cached activity streams, and cached activities reset.', 'success');
        updateProgress([]);
        filterActivities(); // Re-render activities after reset
    }
}

// Update Progress function
function updateProgress(newlyCompletedPoints) {
    // Merge new points with existing, ensuring no duplicates based on point coordinates
    const existingPoints = JSON.parse(localStorage.getItem(COMPLETED_POINTS_KEY) || '[]');

    // Convert coordinates to strings for easier comparison
    const existingPointStrings = new Set(existingPoints.map(p => JSON.stringify(p)));
    const mergedPoints = [...existingPoints];

    newlyCompletedPoints.forEach(p => {
        if (!existingPointStrings.has(JSON.stringify(p))) {
            mergedPoints.push(p);
            existingPointStrings.add(JSON.stringify(p)); // Add to set for quick lookups
        }
    });

    localStorage.setItem(COMPLETED_POINTS_KEY, JSON.stringify(mergedPoints));
    processedCompletedPoints = mergedPoints; // Update global variable

    // Recalculate completed distance
    let currentCompletedDistance = 0;
    if (processedCompletedPoints.length > 1) {
        // Create a LineString from the completed points to calculate its length
        const line = turf.lineString(processedCompletedPoints.map(p => [p.lon, p.lat]));
        currentCompletedDistance = turf.length(line, { units: 'kilometers' });
    }

    const progressPercentage = swcpTotalDistance > 0 ? (currentCompletedDistance / swcpTotalDistance * 100) : 0;

    UIElements.completedDistance.textContent = currentCompletedDistance.toFixed(2);
    UIElements.progressPercentage.textContent = `${progressPercentage.toFixed(2)}%`;
    UIElements.progressBar.style.width = `${progressPercentage}%`;

    // Render completed segments on map
    renderCompletedSegments(processedCompletedPoints);
    log(`Progress updated: ${currentCompletedDistance.toFixed(2)} km (${progressPercentage.toFixed(2)}%).`);
}


// Render Completed Segments on Map function
function renderCompletedSegments(completedPoints) {
    completedSegmentsLayer.clearLayers(); // Clear previous layers

    if (completedPoints.length < 2) return;

    // Create a LineString from the completed points
    const line = turf.lineString(completedPoints.map(p => [p.lon, p.lat]));

    L.geoJSON(line.geometry, {
        style: {
            color: 'red', // Color for completed segments
            weight: 5,
            opacity: 0.9
        }
    }).addTo(completedSegmentsLayer);
}

// Process Activities function (Web Worker Integration)
async function processActivities(activities) {
    if (!analysisWorker) {
        analysisWorker = new Worker('swcp_analysis_worker.js'); // Assuming you have this worker file
        log('Web Worker initialized.', 'info');

        analysisWorker.onmessage = (e) => {
            if (e.data.type === 'log') {
                log(`Worker: ${e.data.message}`, e.data.logType || 'info');
            } else if (e.data.type === 'progress') {
                log(`Worker Progress: ${e.data.message}`, 'info');
            } else if (e.data.type === 'result') {
                log('Worker finished processing activities. Updating UI...', 'success');
                const { completedPoints, processedActivityIds } = e.data;
                updateProgress(completedPoints);
                localStorage.setItem(PROCESSED_ACTIVITIES_KEY, JSON.stringify(processedActivityIds));
                UIElements.progressSection.classList.remove('hidden'); // Show progress section
            } else if (e.data.type === 'error') {
                log(`Worker Error: ${e.data.message}`, 'error');
            }
        };

        analysisWorker.onerror = (e) => {
            log(`Web Worker error: ${e.message}`, 'error');
        };

        // Send SWCP GeoJSON to the worker if it's already loaded
        if (swcpGeoJSON) {
            analysisWorker.postMessage({ type: 'init_swcp', swcpGeoJSONString: JSON.stringify(swcpGeoJSON) });
            log('SWCP GeoJSON sent to worker for initialization after worker was created.');
        }
    }

    log(`Sending ${activities.length} activities to worker for analysis...`);
    // Filter out activities already processed based on localStorage
    const processedActivityIds = new Set(JSON.parse(localStorage.getItem(PROCESSED_ACTIVITIES_KEY) || '[]'));
    const activitiesToProcess = activities.filter(activity => !processedActivityIds.has(activity.id));

    if (activitiesToProcess.length === 0) {
        log('No new activities to process.', 'info');
        UIElements.progressSection.classList.remove('hidden'); // Show progress section even if no new activities
        return;
    }

    UIElements.progressSection.classList.add('hidden'); // Hide progress section while processing
    analysisWorker.postMessage({
        type: 'analyze_activities',
        activities: activitiesToProcess,
        existingProcessedActivityIds: Array.from(processedActivityIds)
    });
}

// Render Activities in List function
function renderActivities(activities) {
    const activityList = UIElements.activityListContainer;
    activityList.innerHTML = ''; // Clear previous list

    if (activities.length === 0) {
        activityList.innerHTML = '<p class="text-gray-600 text-center py-4">No activities to display.</p>';
        return;
    }

    activities.forEach(activity => {
        const activityCard = document.createElement('div');
        activityCard.className = 'bg-white p-4 rounded-lg shadow-md';
        const activityDate = new Date(activity.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });

        // Check if activity has coordinates/polyline to determine if it's "mappable"
        const isMappable = activity.map && activity.map.summary_polyline;

        activityCard.innerHTML = `
            <h3 class="text-lg font-semibold text-gray-900">${activity.name}</h3>
            <p class="text-sm text-gray-600">${activityDate} - ${activity.type} - ${activity.distance ? (activity.distance / 1000).toFixed(2) + ' km' : 'N/A'}</p>
            <div class="activity-map mt-3 mb-3 hidden" id="map-${activity.id}"></div>
            <div class="flex justify-end gap-2 mt-3">
                ${isMappable ? `<button class="btn-base btn-primary text-sm analyze-btn" data-activity-id="${activity.id}" data-activity-type="${activity.type}">View on Map</button>` : `<span class="text-gray-500 text-sm">No map data</span>`}
                <button class="btn-base btn-secondary text-sm add-description-btn" data-activity-id="${activity.id}" data-activity-name="${activity.name}">Add to Strava Description</button>
            </div>
        `;
        activityList.appendChild(activityCard);
    });

    // Add event listeners for "View on Map" buttons
    activityList.querySelectorAll('.analyze-btn').forEach(button => {
        button.addEventListener('click', (event) => {
            const activityId = event.target.dataset.activityId;
            const activityType = event.target.dataset.activityType;
            const activity = allFetchedActivities.find(a => a.id == activityId);
            if (activity) {
                toggleActivityMap(activity);
            }
        });
    });

    // Add event listeners for "Add to Description" buttons
    activityList.querySelectorAll('.add-description-btn').forEach(button => {
        button.addEventListener('click', async (event) => {
            const activityId = event.target.dataset.activityId;
            const activityName = event.target.dataset.activityName;
            const activity = { id: activityId, name: activityName }; // Create a minimal activity object
            await updateActivityDescription(activity, event.target);
        });
    });
}


let currentActivityMap = null; // To keep track of the currently open activity map
let currentActivityMapId = null;

async function toggleActivityMap(activity) {
    const mapContainer = document.getElementById(`map-${activity.id}`);

    if (mapContainer.classList.contains('hidden')) {
        // If another map is open, close it first
        if (currentActivityMap && currentActivityMapId && currentActivityMapId !== activity.id) {
            document.getElementById(`map-${currentActivityMapId}`).classList.add('hidden');
            currentActivityMap.remove(); // Dispose the old map to free resources
            currentActivityMap = null;
        }

        mapContainer.classList.remove('hidden');
        await sleep(100); // Give time for rendering

        // Initialize map if not already done
        if (!currentActivityMap || currentActivityMapId !== activity.id) {
            if (currentActivityMap) currentActivityMap.remove(); // Ensure old map is removed
            currentActivityMap = L.map(mapContainer).setView([50.5, -4.0], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(currentActivityMap);
            currentActivityMapId = activity.id;
        }

        log(`Loading polyline for activity ${activity.id}...`, 'info');
        try {
            const polyline = activity.map.summary_polyline;
            const latlngs = polyline.length ? Polyline.decode(polyline) : [];

            if (latlngs.length > 0) {
                const path = L.polyline(latlngs, { color: 'red' }).addTo(currentActivityMap);
                currentActivityMap.fitBounds(path.getBounds());
                log('Polyline loaded.', 'success');
            } else {
                log('No polyline data for this activity.', 'warn');
            }
        } catch (e) {
            log(`Error loading polyline for activity ${activity.id}: ${e.message}`, 'error');
        }

        // Invalidate map size to ensure it renders correctly after becoming visible
        currentActivityMap.invalidateSize();
    } else {
        // Map is currently open, close it
        mapContainer.classList.add('hidden');
        if (currentActivityMap) {
            currentActivityMap.remove(); // Dispose the map
            currentActivityMap = null;
            currentActivityMapId = null;
            log('Activity map closed and disposed.', 'info');
        }
    }
}


// Filter activities based on current type filter and search term
function filterActivities() {
    const searchTerm = UIElements.activitySearchBox ? UIElements.activitySearchBox.value.toLowerCase() : '';
    const activeFilterButton = UIElements.filterButtons.querySelector('.active');
    const typeFilter = activeFilterButton ? activeFilterButton.dataset.filter : 'all';

    let filtered = allFetchedActivities;

    if (typeFilter !== 'all') {
        filtered = filtered.filter(activity => activity.type === typeFilter);
    }

    if (searchTerm) {
        filtered = filtered.filter(activity =>
            activity.name.toLowerCase().includes(searchTerm) ||
            (activity.type && activity.type.toLowerCase().includes(searchTerm))
        );
    }
    renderActivities(filtered);
}


// Fetch All Activities function
async function fetchAllActivities() {
    // No need to get accessToken here directly, makeStravaApiRequest handles it
    const cachedActivities = localStorage.getItem(CACHED_ACTIVITIES_KEY);
    const cachedTimestamp = localStorage.getItem(CACHED_ACTIVITIES_TIMESTAMP_KEY);
    const now = new Date().getTime();

    if (cachedActivities && cachedTimestamp && (now - parseInt(cachedTimestamp) < CACHE_EXPIRY_MS)) {
        log('Loading activities from cache...', 'info');
        const allRawActivities = JSON.parse(cachedActivities);
        const relevantActivities = allRawActivities.filter(a => ['Hike'].includes(a.type)); // Filter relevant types here
        log(`Successfully loaded ${relevantActivities.length} relevant activities from cache.`, 'success');
        return relevantActivities;
    }

    let allRawActivities = [];
    let page = 1;
    const perPage = 100;

    log('Fetching activities from Strava (cache expired or not found), this might take a moment...');

    while (true) {
        try {
            log(`Requesting page ${page} of activities...`);
            // Use the new wrapper function
            const response = await makeStravaApiRequest(`/athlete/activities?page=${page}&per_page=${perPage}`);

            // If makeStravaApiRequest returned null (meaning a redirect or critical error happened), stop
            if (!response) {
                log('Authentication issue during activity fetch. Stopping fetch.', 'info');
                // The makeStravaApiRequest function should have handled re-auth or redirect
                // so just break and let the calling function handle the empty result.
                return []; // Return empty array to signal no activities fetched
            }

            const pageActivities = await response.json();

            if (pageActivities.length === 0) {
                log(`No more activities found after page ${page}.`, 'info');
                break; // No more activities
            }
            allRawActivities = allRawActivities.concat(pageActivities);
            page++;
            // Optional: Add a small delay to avoid hitting rate limits too fast
            await sleep(100);

        } catch (e) {
            log(`Failed to fetch activities: ${e.message}`, 'error');
            // If there was an error that makeStravaApiRequest couldn't handle
            // (e.g., permanent API error, or refresh failed after retry),
            // it will have been logged and potentially redirected.
            // You might want to display a user-friendly error message here.
            alert(`Failed to fetch activities. Please try connecting to Strava again. Error: ${e.message}`);
            // Force re-login if a critical error occurs
            sessionStorage.removeItem(ACCESS_TOKEN_KEY);
            localStorage.removeItem(REFRESH_TOKEN_KEY);
            localStorage.removeItem(ACCESS_TOKEN_EXPIRY_KEY);
            window.location.href = getStravaAuthUrl(); // Redirect to auth
            return []; // Return empty array or throw, depending on desired behavior
        }
    }

    // Only include activities of type 'Hike' for the main tracker logic
    const relevantActivities = allRawActivities.filter(a => ['Hike'].includes(a.type));
    log(`Finished fetching. Total ${allRawActivities.length} raw activities, ${relevantActivities.length} relevant activities for tracking.`, 'success');

    // Cache all activities (for filtering later)
    localStorage.setItem(CACHED_ACTIVITIES_KEY, JSON.stringify(allRawActivities));
    localStorage.setItem(CACHED_ACTIVITIES_TIMESTAMP_KEY, now.toString());

    return relevantActivities;
}


// Update Activity Description function
async function updateActivityDescription(activity, button) {
    let currentPercentage = 'N/A';
    try {
        currentPercentage = UIElements.progressPercentage.textContent; // Ensure this element exists
    } catch (e) {
        log("Could not get current percentage from UI.", "warn");
    }

    button.disabled = true;
    const originalText = button.textContent;
    button.textContent = 'Fetching description...';

    let existingDescription = '';
    try {
        // Use the new wrapper function for fetching activity details
        const response = await makeStravaApiRequest(`/activities/${activity.id}`);
        if (!response) { // If makeStravaApiRequest caused a redirect/error, it returns null
            log('Authentication redirect occurred during description fetch. Aborting description update.', 'info');
            return;
        }
        const fullActivity = await response.json();
        existingDescription = fullActivity.description || '';
        log("Current description fetched successfully.", "success");
    } catch (e) {
        log(`Failed to fetch current description: ${e.message}`, "error");
        button.textContent = 'Error';
        setTimeout(() => { button.textContent = originalText; button.disabled = false; }, 2000);
        return;
    }

    const newDescriptionText = `${currentPercentage} of the South West Coast Path completed 🥾`;
    let updatedDescription;

    if (existingDescription.trim().length > 0) {
        // Check if the newDescriptionText is already present in the existing description
        if (existingDescription.includes(newDescriptionText)) {
            log('Description already contains the progress update. No change needed.', 'info');
            button.textContent = 'Already Added!';
            setTimeout(() => { button.textContent = originalText; button.disabled = false; }, 2000);
            return;
        }
        updatedDescription = newDescriptionText + '\n\n' + existingDescription; // New: Prepend
    } else {
        updatedDescription = newDescriptionText;
    }

    log(`Updating description for "${activity.name}"`);
    try {
        // Use the new wrapper function for updating activity
        const response = await makeStravaApiRequest(`/activities/${activity.id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ description: updatedDescription })
        });

        if (!response) { // If makeStravaApiRequest caused a redirect/error
            log('Authentication redirect occurred during description update. Aborting.', 'info');
            return;
        }

        log('Description updated on Strava.', 'success');
        button.textContent = 'Description Added!';
        setTimeout(() => { button.textContent = originalText; button.disabled = false; }, 2000);
    } catch(e) {
        log(`Error updating description: ${e.message}`, 'error');
        button.textContent = 'Error';
        setTimeout(() => { button.textContent = originalText; button.disabled = false; }, 2000);
    }
}


// --- Event Listeners ---
document.addEventListener('DOMContentLoaded', () => {
    cacheUIElements(); // Cache elements once DOM is ready

    // Connect Button
    if (UIElements.connectButton) {
        UIElements.connectButton.addEventListener('click', () => {
            const authUrl = getStravaAuthUrl();
            if (authUrl) {
                window.location.href = authUrl;
            }
        });
    }

    // Reset Button
    if (UIElements.resetButton) {
        UIElements.resetButton.addEventListener('click', resetProgress);
    }

    // Activity Search Box
    if (UIElements.activitySearchBox) {
        UIElements.activitySearchBox.addEventListener('input', filterActivities);
    }

    // Activity Filter Buttons
    if (UIElements.filterButtons) {
        UIElements.filterButtons.addEventListener('click', (event) => {
            if (event.target.classList.contains('filter-btn')) {
                // Remove 'active' from all buttons
                UIElements.filterButtons.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                // Add 'active' to the clicked button
                event.target.classList.add('active');
                filterActivities();
            }
        });
    }


    // Initialize Web Worker if supported
    if (window.Worker) {
        log('Web Workers supported. Initializing analysis worker...', 'info');
        analysisWorker = new Worker('analysisWorker.js'); // Assuming analysisWorker.js exists
        // Setup initial message handler for worker logs/errors
        analysisWorker.onmessage = (e) => {
            if (e.data.type === 'log') {
                log(`Worker: ${e.data.message}`, e.data.logType || 'info');
            } else if (e.data.type === 'error') {
                log(`Worker Error: ${e.data.message}`, 'error');
            }
            // Other result handling is done in processActivities
        };
        analysisWorker.onerror = (e) => {
            log(`Web Worker initial error: ${e.message}`, 'error');
        };
    } else {
        log('Web Workers not supported in this browser. Performance may be impacted for large data sets.', 'warn');
    }

    // Initial check for Strava callback or existing tokens
    handleStravaCallback();
    // initializeApp will be called from handleStravaCallback if authentication is successful.
    // If not, it will be called directly from DOMContentLoaded for cases where no code in URL.
    // However, initializeApp should also be called directly here to ensure it runs even if
    // not a callback or if tokens are already valid. The initial call in handleStravaCallback is
    // specifically for the URL code. Let's make it more robust.

    // Better initialization flow:
    // Call initializeApp first. It will check for existing tokens/callback.
    // If a callback is in progress, handleStravaCallback (called by initializeApp) will manage
    // the UI and then call initializeApp again internally.
    // If no callback, initializeApp will proceed with token checks directly.
    // This makes the flow cleaner.
    // Removing direct handleStravaCallback() here, as initializeApp will call it.
    // Let's call initializeApp after the DOMContentLoaded listener is set up.
    // Wait, the existing structure in handleStravaCallback is:
    // if (code) { // Process code, then await initializeApp() } else { // Show login screen }
    // This means initializeApp() is only called if a code is present.
    // We need to call initializeApp() initially to check for existing tokens as well.
    // Yes, the original structure had initializeApp() being called only after a callback code was processed.
    // It should be called immediately on DOMContentLoaded to determine app state.

    // Adjusted logic for initial app load:
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');

    if (code) {
        // If there's a code, it means we're in a callback flow.
        // handleStravaCallback will exchange code, store tokens, and then call initializeApp.
        handleStravaCallback();
    } else {
        // No code in URL, so just try to initialize app based on existing tokens.
        initializeApp();
    }
});

</script>

</body>
</html>
